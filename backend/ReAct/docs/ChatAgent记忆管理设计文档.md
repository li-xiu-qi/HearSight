# ChatAgent 记忆管理设计文档

## 概述

ChatAgent 的记忆管理模块负责监控对话上下文的长度，当积累的消息内容超过 LLM 的上下文限制时，自动对历史对话进行智能总结，避免上下文过长导致的性能问题和记忆限制。

## 核心问题

### 上下文长度限制
- LLM 的上下文长度有限（通过 `settings.llm_context_length` 配置）
- 长时间对话会导致消息历史积累，超过上下文限制
- 超出限制可能导致：
  - API 调用失败
  - 推理质量下降
  - 响应不完整

### 记忆管理需求
- 保留关键对话信息
- 维持对话连贯性
- 控制上下文长度
- 支持多轮对话场景

## 设计方案

### 1. 记忆管理架构

#### MemoryManager 类
对话记忆管理器，负责记忆的添加、检查、总结和上下文重组。

**核心数据结构**：
- `conversation_summary`: 累积的对话摘要字符串，随着对话进行逐步更新，存储经过压缩的关键对话信息
- `message_buffer`: 消息缓冲区列表，存储完整的消息历史，包括系统提示、用户问题和助手回复

**设计理念**：
- `conversation_summary` 实现记忆压缩，通过 LLM 生成的摘要保持对话连贯性
- `message_buffer` 保留完整上下文，支持精确的上下文重组和长度计算

#### 集成到 ChatAgent
在 ChatAgent 初始化时自动集成记忆管理功能。

#### 记忆类型分离
为了避免不同类型记忆的混淆，ChatAgent 采用分层记忆管理策略：

**对话记忆（MemoryManager）**：

- 管理用户与助手之间的对话历史
- 记录用户问题和助手最终答案
- 用于维持多轮对话的连贯性
- 当上下文过长时进行智能总结压缩

**任务执行记忆（BaseAgent）**：

- 管理单次任务执行的内部推理过程
- 包括 ReAct 循环中的 Thought、Action、Observation 等步骤
- 记录工具调用和中间结果
- 任务完成后即释放，不累积到对话记忆中

**分离优势**：

- 避免任务执行的临时记忆污染对话上下文
- 保持对话记忆的简洁性和相关性
- 支持任务执行的独立调试和优化
- 提高记忆管理的精确性和效率

### 2. 记忆总结策略

#### 触发条件

- 消息历史总长度超过 `context_limit * 0.8`（80%阈值）
- 消息数量超过预设上限（如50条）
- 手动触发总结

#### 总结内容

- 保留用户关键问题和Agent核心回答
- 总结工具调用结果和推理过程
- 维持对话主题和上下文关系
- 过滤冗余信息

#### 增量总结策略（推荐）

采用基于上下文工程的增量总结方法，每次基于当前摘要和新对话内容生成更新后的摘要：

**核心思路**：

- 维护一个累积的对话摘要
- 每次需要总结时，将新对话内容追加到现有摘要中
- 通过 LLM 生成连贯的新摘要
- 避免一次性处理全部历史消息

**总结提示词模板**：

```text
请逐步总结提供的对话内容，将其补充到之前的摘要中并返回一个新的摘要。

示例：
当前摘要：
用户询问了人工智能的发展现状。

新的对话内容：
用户：人工智能在医疗领域有哪些应用？
助手：人工智能在医疗领域可以帮助诊断疾病、分析医学影像、药物研发等方面。

新摘要：
用户询问了人工智能的发展现状和医疗应用，AI在医疗领域可以帮助诊断疾病、分析医学影像和药物研发。

当前摘要：
{current_summary}

新的对话内容：
{new_dialogue_content}

新摘要：
```

**示例流程**：

```text
初始摘要：""（空）

第一次总结：
当前摘要：
新的对话内容：
用户：什么是人工智能？
AI：人工智能是模拟人类智能的技术。

新摘要：
用户询问人工智能的定义，AI解释它是模拟人类智能的技术。

第二次总结：
当前摘要：
用户询问人工智能的定义，AI解释它是模拟人类智能的技术。

新的对话内容：
用户：人工智能有哪些应用？
AI：人工智能在医疗、金融、教育等领域都有广泛应用。

新摘要：
用户询问人工智能的定义和应用，AI解释它是模拟人类智能的技术，在医疗、金融、教育等领域都有广泛应用。
```

**优势**：

- **渐进式积累**：每次只处理新增内容，避免重复处理历史
- **上下文保持**：通过累积摘要维持对话连贯性
- **长度控制**：可以控制每次总结的粒度
- **质量保证**：基于示例的提示词生成更稳定的总结

### 3. 上下文重组策略

#### 消息结构重组

```json
原始消息历史：
[
    {"role": "system", "content": "系统提示"},
    {"role": "user", "content": "问题1"},
    {"role": "assistant", "content": "回答1"},
    ... (更多消息)
    {"role": "user", "content": "当前问题"}
]

重组后消息历史：
[
    {"role": "system", "content": "系统提示 + 对话总结"},
    {"role": "user", "content": "当前问题"}
]
```

#### 系统提示更新

```text
原始系统提示：
"你是一个聊天助手..."

更新后系统提示：
"你是一个聊天助手...

对话历史总结：
- 之前讨论了话题A，主要结论是...
- 用户询问了问题B，得到了回答...
- 工具调用结果显示..."
```
