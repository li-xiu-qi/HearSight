# -*- coding: utf-8 -*-
"""bilibili cookie处理模块"""

import json
import logging
from pathlib import Path
from typing import Optional, Dict, List

logger = logging.getLogger(__name__)

COOKIES_PATH = Path(__file__).parent / "datas" / "bilibili_cookies.json"


def get_cookies_file_path() -> Path:
    """获取cookie文件路径"""
    return COOKIES_PATH


def cookies_to_netscape(cookies: List[Dict], dest: str) -> bool:
    """
    将 Playwright cookie 列表导出为 Netscape cookies.txt 格式，供 yt-dlp 使用

    Args:
        cookies: cookie 列表，每项包含 name, value, domain, path, secure, expires
        dest: 输出文件路径

    Returns:
        bool: 是否成功
    """
    try:
        lines = ["# Netscape HTTP Cookie File\n", "# This file was generated by bilibili_login_handler\n\n"]
        for c in cookies:
            domain = c.get('domain', '')
            flag = 'TRUE' if domain.startswith('.') else 'FALSE'
            path = c.get('path', '/')
            secure = 'TRUE' if c.get('secure', False) else 'FALSE'
            expires = str(int(c.get('expires', 0)))
            name = c.get('name', '')
            value = c.get('value', '')
            lines.append(f"{domain}\t{flag}\t{path}\t{secure}\t{expires}\t{name}\t{value}\n")
        with open(dest, 'w', encoding='utf-8') as f:
            f.writelines(lines)
        logger.info(f"已将cookie导出为 Netscape cookies 文件: {dest}")
        return True
    except Exception as e:
        logger.error(f"导出 netscape cookie 失败: {e}")
        return False


def load_cookies() -> Optional[List[Dict]]:
    """
    加载保存的cookie

    Returns:
        List[Dict]: cookie列表，如果文件不存在返回None
    """
    try:
        if COOKIES_PATH.exists():
            with open(COOKIES_PATH, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
                logger.info(f"成功加载cookie: {COOKIES_PATH}")
                return cookies
        else:
            logger.info(f"cookie文件不存在: {COOKIES_PATH}")
            return None
    except Exception as e:
        logger.error(f"加载cookie失败: {e}")
        return None


def save_cookies(cookies: List[Dict]) -> bool:
    """
    保存cookie到文件

    Args:
        cookies: cookie列表

    Returns:
        bool: 是否保存成功
    """
    try:
        COOKIES_PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(COOKIES_PATH, 'w', encoding='utf-8') as f:
            json.dump(cookies, f, indent=2, ensure_ascii=False)
        logger.info(f"cookie已保存到: {COOKIES_PATH}")
        return True
    except Exception as e:
        logger.error(f"保存cookie失败: {e}")
        return False


async def get_browser_cookies(page) -> List[Dict]:
    """
    从browser context中提取cookies

    Args:
        page: playwright page对象

    Returns:
        Dict: cookies字典
    """
    try:
        cookies_list = await page.context.cookies()
        # 保持完整cookie对象（name, value, domain, path, secure, expires等）
        result = []
        for cookie in cookies_list:
            if cookie.get('name') and cookie.get('value'):
                result.append({
                    'name': cookie.get('name'),
                    'value': cookie.get('value'),
                    'domain': cookie.get('domain', ''),
                    'path': cookie.get('path', '/'),
                    'secure': cookie.get('secure', False),
                    'expires': cookie.get('expires', 0),
                })
        return result
    except Exception as e:
        logger.error(f"获取browser cookies失败: {e}")
        return []


async def login_and_get_cookies(headless: bool = False) -> Optional[List[Dict]]:
    """
    使用playwright驱动浏览器登录bilibili并获取cookie
    等待用户登录完成（通过检测页面导航或用户确认）

    Args:
        headless: 是否使用无头模式

    Returns:
        Dict: cookie字典，如果获取失败返回None
    """
    try:
        from playwright.async_api import async_playwright
    except ImportError:
        logger.error("playwright未安装，请运行: pip install playwright")
        return None

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=headless,
            args=["--disable-blink-features=AutomationControlled"],
        )
        context = await browser.new_context(
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            viewport={"width": 1920, "height": 1080},
        )
        page = await context.new_page()

        try:
            logger.info("正在打开bilibili首页...")
            await page.goto("https://www.bilibili.com", wait_until="networkidle")

            logger.info("请在浏览器中完成登录操作（扫码或输入账号密码）")
            logger.info("登录成功后，浏览器会自动跳转，程序将自动保存cookie")

            # 注入初始化脚本，隐藏自动化标识
            await page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false
                });
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5]
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['zh-CN', 'zh', 'en-US', 'en']
                });
            """)

            # 等待登录后的页面变化，超时设置为5分钟，轮询URL变化判断登录完成
            timeout = 300000  # 5分钟
            check_interval = 2000
            elapsed = 0
            while elapsed < timeout:
                current_url = page.url
                # 如果 URL 不再包含 passport/login，则认为登录完成
                if "bilibili.com" in current_url and "passport" not in current_url and "login" not in current_url:
                    logger.info("检测到登录成功，URL已变为: " + current_url)
                    break
                await page.wait_for_timeout(check_interval)
                elapsed += check_interval

            # 再等一小段时间确保cookie完全设置
            await page.wait_for_timeout(1000)

            logger.info("正在获取cookie...")
            cookies = await get_browser_cookies(page)

            if cookies:
                logger.info(f"成功获取cookie，共{len(cookies)}个")
                save_cookies(cookies)
                return cookies
            else:
                logger.warning("未获取到cookie")
                return None

        except Exception as e:
            logger.error(f"登录过程出错: {e}")
            return None
        finally:
            try:
                await browser.close()
            except Exception:
                pass


def login_and_get_cookies_sync(headless: bool = False) -> Optional[Dict]:
    """
    同步版本的登录和获取cookie

    Args:
        headless: 是否使用无头模式

    Returns:
        Dict: cookie字典，如果登录失败返回None
    """
    import asyncio
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    try:
        return loop.run_until_complete(login_and_get_cookies(headless=headless))
    finally:
        pass
